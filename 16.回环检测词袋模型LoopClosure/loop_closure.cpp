/*=================================================================================
 *	                    Copyleft! 2018 William Yu
 *          Some rights reserved：CC(creativecommons.org)BY-NC-SA
 *                      Copyleft! 2018 William Yu
 *      版权部分所有，遵循CC(creativecommons.org)BY-NC-SA协议授权方式使用
 *
 * Filename                : 
 * Description             : 视觉SLAM十四讲/ch12 学习记录
 *                           回环检测-相似度计算
 * Reference               : 
 * Programmer(s)           : William Yu, windmillyucong@163.com
 * Company                 : HUST, DMET国家重点实验室FOCUS团队
 * Modification History	   : ver1.0, 2018.05.06, William Yu
                             ver1.1, 2018.05.12, William Yu, add notes
=================================================================================*/

//--根据前面训练的字典计算相似性评分


/// Include Files
#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <iostream>
#include <vector>
#include <string>

using namespace cv;
using namespace std;

/// Function Definitions
/**
 * @function main
 * @brief 
 * @param  None
 * @retval None
 */
int main( int argc, char** argv )
{
    // read the images and database  
    cout<<"reading database"<<endl;

    //DBoW3::Vocabulary vocab("../data/vocabulary.yml.gz");
    //使用大字典取消下行注释，注释掉上行
    DBoW3::Vocabulary vocab("../data/focus_vocab_larger.yml.gz");  // use large vocab if you want: 
    if ( vocab.empty() )
    {
        cerr<<"Vocabulary does not exist."<<endl;
        return 1;
    }


    cout<<"reading images... "<<endl;
    vector<Mat> images; 
    for ( int i=0; i<10; i++ )
    {
        string path = "../data_focus_part/"+to_string(i)+".png";
        images.push_back( imread(path) );
    }
    





    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.  
    // detect ORB features
    //检测ORB特征
    cout<<"detecting ORB features ... "<<endl;
    Ptr< Feature2D > detector = ORB::create();
    vector<Mat> descriptors;
    for ( Mat& image:images )
    {
        vector<KeyPoint> keypoints; 
        Mat descriptor;
        detector->detectAndCompute( image, Mat(), keypoints, descriptor );
        descriptors.push_back( descriptor );
    }
    







    // // we can compare the images directly or we can compare one image to a database 
    // //计算图像与图像的相似度
    // // images :
    // cout<<"comparing images with images "<<endl;
    // for ( int i=0; i<images.size(); i++ )
    // {
    //     DBoW3::BowVector v1;
    //     vocab.transform( descriptors[i], v1 );
    //     for ( int j=i; j<images.size(); j++ )
    //     {
    //         DBoW3::BowVector v2;
    //         vocab.transform( descriptors[j], v2 );
    //         double score = vocab.score(v1, v2);
    //         cout<<"image "<<i<<" vs image "<<j<<" : "<<score<<endl;
    //     }
    //     cout<<endl;
    // }
    





    //计算图像与模型的相似度
    // or with database 
    cout<<"comparing images with database "<<endl;
    DBoW3::Database db( vocab, false, 0);
    for ( int i=0; i<descriptors.size(); i++ )
        db.add(descriptors[i]);
    cout<<"database info: "<<db<<endl;
    // for ( int i=0; i<descriptors.size(); i++ )
    // {
    //     DBoW3::QueryResults ret;
    //     db.query( descriptors[i], ret, 4);      // max result=4
    //     cout<<"searching for image "<<i<<" returns "<<ret<<endl<<endl;
    // }
    //只输出第0张图片结果
    DBoW3::QueryResults ret;
    db.query( descriptors[0], ret, 4);    //第0张图片为实验假设回环数据  // max result=4
    cout<<"searching for image "<<0<<" returns "<<ret<<endl<<endl;

    cout<<"done."<<endl;


    
}